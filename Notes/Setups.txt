Parabolspiegel: ./MainYeeOctreeNoDebug.exe -t3001 -p10 -i5 -m5 -w2 -s5
make MainYeeOctreeNoDebug; ./MainYeeOctreeNoDebug.exe -t3001 -p10 -i5 -m5 -w5
    Gaussian pulse moving to circular glass
make MainYeeOctreeNoDebug; ./MainYeeOctreeNoDebug.exe -t3001 -p10 -i5 -m5 -w3
    kindy tried to set up plane wave source moving to circular lense
make MainYeeOctreeNoDebug; ./MainYeeOctreeNoDebug.exe -t91 -n 128 32 0 -p10 -i0 -m0 -s0 -w 3 0 0 2 100
    sine wave moving to right from left border (and from right border to left because it's periodic)
make MainYeeOctreeNoDebug; ./MainYeeOctreeNoDebug.exe -n 1024 512  0 -w7 -s0 -i0 -m0 -t 3001 -p10
    ellipsoid lense
make OctreeBenchmark; ./OctreeBenchmark.exe -o6 -i6 -m10 --svg 0 --ordering 0..4
    Benchmark for SIMDIM 3
make OctreeBenchmark; ./OctreeBenchmark.exe -o6 -i8 -m12 --svg 0 --ordering 0..4
    Benchmark for SIMDIM 2
make testOctree2 2>&1 | head -n 30; ./testOctree2.exe -o1 -i2 -m2 --svg 1 --ordering 2 --number-of-worldsizes 1
    2 refinements for comparison of 3D-SVG with paper
make testOctree2 2>&1 | head -n 30; ./testOctree2.exe -o3 --svg 1 --ordering 2 --number-of-worldsizes 1
    more complex 3D Case

make MainYeeOctreeNoDebug; mpirun -n 2 ./MainYeeOctreeNoDebug.exe -n 2048 1024 0 -w7 -s0 -i3 -m4 -t 3001 -p10000
    elliptic with partial refinement -> took 287mb per process ( 2 processes )


make MainYeeOctreeNoDebug; mpirun -n 3 ./MainYeeOctreeNoDebug.exe -n 2048 1024 0 -w7 -s0 -o9 -i3 -m6 -t 3001 -p10000
    version where elliptic lense border is refined
    every one of the 3 processes needs ~1 235 436 K -> allocate 2gb on taurus for n=2
    allocate 4gb for n=1 (rewrite program without needing mpi, but with same maxLevel-minLevel in OctreeRefinement
        => ... muss schon exakt so sein, sondern werden ganz andere bereiche refined ... octree refinement kommt also wirklich aus problemstellung ...
    Heimrechner:
        Cells in Octree : 355
            => sollte bis n=128 ohne große Scaling-Probleme laufen, vor allem da jetzt das mit division statt += verbessert wurde: curRank = int( cumulativeCosts / optimalCosts );
        Timestep 3 took 20.4822 seconds
        Timestep 4 took 22.1363 seconds
        Timestep 5 took 24.0264 seconds
      => internalTimestep <=> time between mpi communication ~ 22 / 2^3 = 2.75s => sollte genug sein

    printf '#!/bin/bash\nmpirun hostname' | sbatch --ntasks 3

    module load gcc/4.9.1 openmpi/1.8.3 boost/1.56.0-gnu4.9.1
    mpicc --show-me
        gcc -I/sw/taurus/libraries/openmpi/1.6.5/x86_64/include -pthread -L/sw/taurus/libraries/openmpi/1.6.5/x86_64/lib -lmpi -ldl -lm -lnuma -Wl,--export-dynamic -lrt -lnsl -lutil
    module load scorep/1.3.0-gcc-xmpi-cuda5.5
    salloc -n 1
        make MainYeeOctreeNoDebug
        exit

    printf '#!/bin/bash\nmpirun hostname\nmpirun ./MainYeeOctreeNoDebug.exe -n 2048 1024 0 -w7 -s0 -o9 -i3 -m6 -t 3001 -p10000' | sbatch --exclusive --time=00:20:00 --ntasks 16 --partition=sandy --mem-per-cpu=1927M

    squeue -u s3495379

